// This file is a part of toml++ and is subject to the the terms of the MIT license.
// Copyright (c) Mark Gillard <mark.gillard@outlook.com.au>
// See https://github.com/marzer/tomlplusplus/blob/master/LICENSE for the full license text.
// SPDX-License-Identifier: MIT
//-----
// this file was generated by generate_conformance_tests.py - do not modify it directly

#include "tests.h"
using namespace toml::impl;

TOML_DISABLE_WARNINGS; // unused variable spam

namespace
{
	static constexpr auto array_missing_separator = R"(wrong = [ 1 2 3 ])"sv;
	static constexpr auto array_no_close_2 = R"(x = [42 #)"sv;
	static constexpr auto array_no_close_table_2 = R"(x = [{ key = 42 #)"sv;
	static constexpr auto array_no_close_table = R"(x = [{ key = 42)"sv;
	static constexpr auto array_no_close = R"(long_array = [ 1, 2, 3)"sv;
	static constexpr auto array_tables_1 = R"(# INVALID TOML DOC
fruit = []

[[fruit]] # Not allowed)"sv;
	static constexpr auto array_tables_2 = R"(# INVALID TOML DOC
[[fruit]]
  name = "apple"

  [[fruit.variety]]
    name = "red delicious"

  # This table conflicts with the previous table
  [fruit.variety]
    name = "granny smith")"sv;
	static constexpr auto array_text_after_array_entries = R"(array = [
  "Is there life after an array separator?", No
  "Entry"
])"sv;
	static constexpr auto array_text_before_array_separator = R"(array = [
  "Is there life before an array separator?" No,
  "Entry"
])"sv;
	static constexpr auto array_text_in_array = R"(array = [
  "Entry 1",
  I don't belong,
  "Entry 2",
])"sv;

	static constexpr auto bool_mixed_case = R"(valid = False)"sv;
	static constexpr auto bool_wrong_case_false = R"(b = FALSE)"sv;
	static constexpr auto bool_wrong_case_true = R"(a = TRUE)"sv;

	static constexpr auto datetime_impossible_date = R"(d = 2006-01-50T00:00:00Z)"sv;
	static constexpr auto datetime_no_leads_with_milli = R"(with-milli = 1987-07-5T17:45:00.12Z)"sv;
	static constexpr auto datetime_no_leads = R"(no-leads = 1987-7-05T17:45:00Z)"sv;
	static constexpr auto datetime_no_t = R"(no-t = 1987-07-0517:45:00Z)"sv;
	static constexpr auto datetime_trailing_t = R"(d = 2006-01-30T)"sv;

#if !TOML_LANG_UNRELEASED

	static constexpr auto datetime_no_secs = R"(no-secs = 1987-07-05T17:45Z)"sv;

#endif // !TOML_LANG_UNRELEASED

	static constexpr auto float_double_point_1 = R"(double-point-1 = 0..1)"sv;
	static constexpr auto float_double_point_2 = R"(double-point-2 = 0.1.2)"sv;
	static constexpr auto float_exp_double_e_1 = R"(exp-double-e-1 = 1ee2)"sv;
	static constexpr auto float_exp_double_e_2 = R"(exp-double-e-2 = 1e2e3)"sv;
	static constexpr auto float_exp_double_us = R"(exp-double-us = 1e__23)"sv;
	static constexpr auto float_exp_leading_us = R"(exp-leading-us = 1e_23)"sv;
	static constexpr auto float_exp_point_1 = R"(exp-point-1 = 1e2.3)"sv;
	static constexpr auto float_exp_point_2 = R"(exp-point-2 = 1.e2)"sv;
	static constexpr auto float_exp_trailing_us = R"(exp-trailing-us = 1e_23_)"sv;
	static constexpr auto float_inf_incomplete_1 = R"(inf-incomplete-1 = in)"sv;
	static constexpr auto float_inf_incomplete_2 = R"(inf-incomplete-2 = +in)"sv;
	static constexpr auto float_inf_incomplete_3 = R"(inf-incomplete-3 = -in)"sv;
	static constexpr auto float_inf_underscore = R"(inf_underscore = in_f)"sv;
	static constexpr auto float_leading_point_neg = R"(leading-point-neg = -.12345)"sv;
	static constexpr auto float_leading_point_plus = R"(leading-point-plus = +.12345)"sv;
	static constexpr auto float_leading_point = R"(leading-point = .12345)"sv;
	static constexpr auto float_leading_us = R"(leading-us = _1.2)"sv;
	static constexpr auto float_leading_zero_neg = R"(leading-zero-neg = -03.14)"sv;
	static constexpr auto float_leading_zero_plus = R"(leading-zero-plus = +03.14)"sv;
	static constexpr auto float_leading_zero = R"(leading-zero = 03.14)"sv;
	static constexpr auto float_nan_incomplete_1 = R"(nan-incomplete-1 = na)"sv;
	static constexpr auto float_nan_incomplete_2 = R"(nan-incomplete-2 = +na)"sv;
	static constexpr auto float_nan_incomplete_3 = R"(nan-incomplete-3 = -na)"sv;
	static constexpr auto float_nan_underscore = R"(nan_underscore = na_n)"sv;
	static constexpr auto float_trailing_point_min = R"(trailing-point-min = -1.)"sv;
	static constexpr auto float_trailing_point_plus = R"(trailing-point-plus = +1.)"sv;
	static constexpr auto float_trailing_point = R"(trailing-point = 1.)"sv;
	static constexpr auto float_trailing_us = R"(trailing-us = 1.2_)"sv;
	static constexpr auto float_us_after_point = R"(us-after-point = 1._2)"sv;
	static constexpr auto float_us_before_point = R"(us-before-point = 1_.2)"sv;

	static constexpr auto inline_table_double_comma = R"(t = {x=3,,y=4})"sv;
	static constexpr auto inline_table_empty = R"(t = {,})"sv;
	static constexpr auto inline_table_no_comma = R"(t = {x = 3 y = 4})"sv;

#if !TOML_LANG_UNRELEASED

	static constexpr auto inline_table_linebreak_1 = R"(# No newlines are allowed between the curly braces unless they are valid within
# a value.
simple = { a = 1 
})"sv;
	static constexpr auto inline_table_linebreak_2 = R"(t = {a=1,
b=2})"sv;
	static constexpr auto inline_table_linebreak_3 = R"(t = {a=1
,b=2})"sv;
	static constexpr auto inline_table_linebreak_4 = R"(json_like = {
          first = "Tom",
          last = "Preston-Werner"
})"sv;
	static constexpr auto inline_table_trailing_comma = R"(# A terminating comma (also called trailing comma) is not permitted after the
# last key/value pair in an inline table
abc = { abc = 123, })"sv;

#endif // !TOML_LANG_UNRELEASED

	static constexpr auto integer_capital_bin = R"(capital-bin = 0B0)"sv;
	static constexpr auto integer_capital_hex = R"(capital-hex = 0X1)"sv;
	static constexpr auto integer_capital_oct = R"(capital-oct = 0O0)"sv;
	static constexpr auto integer_double_sign_nex = R"(double-sign-nex = --99)"sv;
	static constexpr auto integer_double_sign_plus = R"(double-sign-plus = ++99)"sv;
	static constexpr auto integer_double_us = R"(double-us = 1__23)"sv;
	static constexpr auto integer_invalid_bin = R"(invalid-bin = 0b0012)"sv;
	static constexpr auto integer_invalid_hex = R"(invalid-hex = 0xaafz)"sv;
	static constexpr auto integer_invalid_oct = R"(invalid-oct = 0o778)"sv;
	static constexpr auto integer_leading_us_bin = R"(leading-us-bin = _0o1)"sv;
	static constexpr auto integer_leading_us_hex = R"(leading-us-hex = _0o1)"sv;
	static constexpr auto integer_leading_us_oct = R"(leading-us-oct = _0o1)"sv;
	static constexpr auto integer_leading_us = R"(leading-us = _123)"sv;
	static constexpr auto integer_leading_zero_1 = R"(leading-zero-1 = 01)"sv;
	static constexpr auto integer_leading_zero_2 = R"(leading-zero-2 = 00)"sv;
	static constexpr auto integer_leading_zero_sign_1 = R"(leading-zero-sign-1 = -01)"sv;
	static constexpr auto integer_leading_zero_sign_2 = R"(leading-zero-sign-2 = +01)"sv;
	static constexpr auto integer_negative_bin = R"(negative-bin = -0b11010110)"sv;
	static constexpr auto integer_negative_hex = R"(negative-hex = -0xff)"sv;
	static constexpr auto integer_negative_oct = R"(negative-oct = -0o99)"sv;
	static constexpr auto integer_positive_bin = R"(positive-bin = +0b11010110)"sv;
	static constexpr auto integer_positive_hex = R"(positive-hex = +0xff)"sv;
	static constexpr auto integer_positive_oct = R"(positive-oct = +0o99)"sv;
	static constexpr auto integer_text_after_integer = R"(answer = 42 the ultimate answer?)"sv;
	static constexpr auto integer_trailing_us_bin = R"(trailing-us-bin = 0b1_)"sv;
	static constexpr auto integer_trailing_us_hex = R"(trailing-us-hex = 0x1_)"sv;
	static constexpr auto integer_trailing_us_oct = R"(trailing-us-oct = 0o1_)"sv;
	static constexpr auto integer_trailing_us = R"(trailing-us = 123_)"sv;
	static constexpr auto integer_us_after_bin = R"(us-after-bin = 0b_1)"sv;
	static constexpr auto integer_us_after_hex = R"(us-after-hex = 0x_1)"sv;
	static constexpr auto integer_us_after_oct = R"(us-after-oct = 0o_1)"sv;

	static constexpr auto key_after_array = R"([[agencies]] owner = "S Cjelli")"sv;
	static constexpr auto key_after_table = R"([error] this = "should not be here")"sv;
	static constexpr auto key_after_value = R"(first = "Tom" last = "Preston-Werner" # INVALID)"sv;
	static constexpr auto key_bare_invalid_character = R"(bare!key = 123)"sv;
	static constexpr auto key_dotted_redefine_table = R"(# Defined a.b as int
a.b = 1
# Tries to access it as table: error
a.b.c = 2)"sv;
	static constexpr auto key_duplicate_keys = R"(dupe = false
dupe = true)"sv;
	static constexpr auto key_duplicate = R"(# DO NOT DO THIS
name = "Tom"
name = "Pradyun")"sv;
	static constexpr auto key_empty = R"(= 1)"sv;
	static constexpr auto key_escape = R"(\u00c0 = "latin capital letter A with grave")"sv;
	static constexpr auto key_hash = R"(a# = 1)"sv;
	static constexpr auto key_multiline = R"("""long
key""" = 1)"sv;
	static constexpr auto key_newline = R"(barekey
   = 123)"sv;
	static constexpr auto key_no_eol = R"(a = 1 b = 2)"sv;
	static constexpr auto key_open_bracket = R"([abc = 1)"sv;
	static constexpr auto key_partial_quoted = R"(partial"quoted" = 5)"sv;
	static constexpr auto key_single_open_bracket = R"([)"sv;
	static constexpr auto key_space = R"(a b = 1)"sv;
	static constexpr auto key_start_bracket = R"([a]
[xyz = 5
[b])"sv;
	static constexpr auto key_two_equals = R"(key= = 1)"sv;
	static constexpr auto key_two_equals2 = R"(a==1)"sv;
	static constexpr auto key_two_equals3 = R"(a=b=1)"sv;
	static constexpr auto key_without_value_1 = R"(key)"sv;
	static constexpr auto key_without_value_2 = R"(key =)"sv;

#if !TOML_LANG_UNRELEASED && UNICODE_LITERALS_OK

	static constexpr auto key_special_character = R"(Î¼ = "greek small letter mu")"sv;

#endif // !TOML_LANG_UNRELEASED && UNICODE_LITERALS_OK

	static constexpr auto string_bad_byte_escape = R"(naughty = "\xAg")"sv;
	static constexpr auto string_bad_codepoint = R"(invalid-codepoint = "This string contains a non scalar unicode codepoint \uD801")"sv;
	static constexpr auto string_bad_concat = R"(no_concat = "first" "second")"sv;
	static constexpr auto string_bad_escape = R"(invalid-escape = "This string has a bad \a escape character.")"sv;
	static constexpr auto string_bad_multiline = R"(multi = "first line
second line")"sv;
	static constexpr auto string_bad_slash_escape = R"(invalid-escape = "This string has a bad \/ escape character.")"sv;
	static constexpr auto string_bad_uni_esc = R"(str = "val\ue")"sv;
	static constexpr auto string_basic_multiline_out_of_range_unicode_escape_1 = R"(a = """\UFFFFFFFF""")"sv;
	static constexpr auto string_basic_multiline_out_of_range_unicode_escape_2 = R"(a = """\U00D80000""")"sv;
	static constexpr auto string_basic_multiline_quotes = R"(str5 = """Here are three quotation marks: """.""")"sv;
	static constexpr auto string_basic_multiline_unknown_escape = R"(a = """\@""")"sv;
	static constexpr auto string_basic_out_of_range_unicode_escape_1 = R"(a = "\UFFFFFFFF")"sv;
	static constexpr auto string_basic_out_of_range_unicode_escape_2 = R"(a = "\U00D80000")"sv;
	static constexpr auto string_basic_unknown_escape = R"(a = "\@")"sv;
	static constexpr auto string_literal_multiline_quotes_1 = R"(a = '''6 apostrophes: '''''')"sv;
	static constexpr auto string_literal_multiline_quotes_2 = R"(a = '''15 apostrophes: '''''''''''''''''')"sv;
	static constexpr auto string_missing_quotes = R"(name = value)"sv;
	static constexpr auto string_multiline_escape_space = R"(a = """
  foo \ \n
  bar""")"sv;
	static constexpr auto string_multiline_no_close_2 = R"(x=""")"sv;
	static constexpr auto string_multiline_no_close = R"(invalid = """
    this will fail)"sv;
	static constexpr auto string_multiline_quotes_1 = R"(a = """6 quotes: """""")"sv;
	static constexpr auto string_multiline_quotes_2 = R"(a = """6 quotes: """""")"sv;
	static constexpr auto string_no_close = R"(no-ending-quote = "One time, at band camp)"sv;
	static constexpr auto string_text_after_string = R"(string = "Is there life after strings?" No.)"sv;
	static constexpr auto string_wrong_close = R"(bad-ending-quote = "double and single')"sv;

#if !TOML_LANG_UNRELEASED

	static constexpr auto string_basic_byte_escapes = R"(answer = "\x33")"sv;

#endif // !TOML_LANG_UNRELEASED

	static constexpr auto table_array_empty = R"([[]]
name = "Born to Run")"sv;
	static constexpr auto table_array_implicit = R"(# This test is a bit tricky. It should fail because the first use of
# `[[albums.songs]]` without first declaring `albums` implies that `albums`
# must be a table. The alternative would be quite weird. Namely, it wouldn't
# comply with the TOML spec: "Each double-bracketed sub-table will belong to 
# the most *recently* defined table element *above* it."
#
# This is in contrast to the *valid* test, table-array-implicit where
# `[[albums.songs]]` works by itself, so long as `[[albums]]` isn't declared
# later. (Although, `[albums]` could be.)
[[albums.songs]]
name = "Glory Days"

[[albums]]
name = "Born in the USA")"sv;
	static constexpr auto table_array_missing_bracket = R"([[albums]
name = "Born to Run")"sv;
	static constexpr auto table_duplicate_key_table = R"([fruit]
type = "apple"

[fruit.type]
apple = "yes")"sv;
	static constexpr auto table_duplicate_table_array = R"([tbl]
[[tbl]])"sv;
	static constexpr auto table_duplicate_table_array2 = R"([[tbl]]
[tbl])"sv;
	static constexpr auto table_duplicate = R"([a]
b = 1

[a]
c = 2)"sv;
	static constexpr auto table_empty_implicit_table = R"([naughty..naughty])"sv;
	static constexpr auto table_empty = R"([])"sv;
	static constexpr auto table_equals_sign = R"([name=bad])"sv;
	static constexpr auto table_injection_1 = R"([a.b.c]
  z = 9
[a]
  b.c.t = "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed"
  
# see https://github.com/toml-lang/toml/issues/846)"sv;
	static constexpr auto table_injection_2 = R"([a.b.c.d]
  z = 9
[a]
  b.c.d.k.t = "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"
  
# see https://github.com/toml-lang/toml/issues/846)"sv;
	static constexpr auto table_llbrace = R"([ [table]])"sv;
	static constexpr auto table_nested_brackets_close = R"([a]b]
zyx = 42)"sv;
	static constexpr auto table_nested_brackets_open = R"([a[b]
zyx = 42)"sv;
	static constexpr auto table_quoted_no_close = R"(["where will it end]
name = value)"sv;
	static constexpr auto table_redefine = R"(# Define b as int, and try to use it as a table: error
[a]
b = 1

[a.b]
c = 2)"sv;
	static constexpr auto table_rrbrace = R"([[table] ])"sv;
	static constexpr auto table_text_after_table = R"([error] this shouldn't be here)"sv;
	static constexpr auto table_whitespace = R"([invalid key])"sv;
	static constexpr auto table_with_pound = R"([key#group]
answer = 42)"sv;
}

TOML_ENABLE_WARNINGS;

TEST_CASE("conformance - burntsushi/invalid")
{
	parsing_should_fail(FILE_LINE_ARGS, array_missing_separator); // array-missing-separator

	parsing_should_fail(FILE_LINE_ARGS, array_no_close_2); // array-no-close-2

	parsing_should_fail(FILE_LINE_ARGS, array_no_close_table_2); // array-no-close-table-2

	parsing_should_fail(FILE_LINE_ARGS, array_no_close_table); // array-no-close-table

	parsing_should_fail(FILE_LINE_ARGS, array_no_close); // array-no-close

	parsing_should_fail(FILE_LINE_ARGS, array_tables_1); // array-tables-1

	parsing_should_fail(FILE_LINE_ARGS, array_tables_2); // array-tables-2

	parsing_should_fail(FILE_LINE_ARGS, array_text_after_array_entries); // array-text-after-array-entries

	parsing_should_fail(FILE_LINE_ARGS, array_text_before_array_separator); // array-text-before-array-separator

	parsing_should_fail(FILE_LINE_ARGS, array_text_in_array); // array-text-in-array

	parsing_should_fail(FILE_LINE_ARGS, bool_mixed_case); // bool-mixed-case

	parsing_should_fail(FILE_LINE_ARGS, bool_wrong_case_false); // bool-wrong-case-false

	parsing_should_fail(FILE_LINE_ARGS, bool_wrong_case_true); // bool-wrong-case-true

	parsing_should_fail(FILE_LINE_ARGS, datetime_impossible_date); // datetime-impossible-date

	parsing_should_fail(FILE_LINE_ARGS, datetime_no_leads_with_milli); // datetime-no-leads-with-milli

	parsing_should_fail(FILE_LINE_ARGS, datetime_no_leads); // datetime-no-leads

	parsing_should_fail(FILE_LINE_ARGS, datetime_no_t); // datetime-no-t

	parsing_should_fail(FILE_LINE_ARGS, datetime_trailing_t); // datetime-trailing-t

#if !TOML_LANG_UNRELEASED

	parsing_should_fail(FILE_LINE_ARGS, datetime_no_secs); // datetime-no-secs

#endif // !TOML_LANG_UNRELEASED

	parsing_should_fail(FILE_LINE_ARGS, float_double_point_1); // float-double-point-1

	parsing_should_fail(FILE_LINE_ARGS, float_double_point_2); // float-double-point-2

	parsing_should_fail(FILE_LINE_ARGS, float_exp_double_e_1); // float-exp-double-e-1

	parsing_should_fail(FILE_LINE_ARGS, float_exp_double_e_2); // float-exp-double-e-2

	parsing_should_fail(FILE_LINE_ARGS, float_exp_double_us); // float-exp-double-us

	parsing_should_fail(FILE_LINE_ARGS, float_exp_leading_us); // float-exp-leading-us

	parsing_should_fail(FILE_LINE_ARGS, float_exp_point_1); // float-exp-point-1

	parsing_should_fail(FILE_LINE_ARGS, float_exp_point_2); // float-exp-point-2

	parsing_should_fail(FILE_LINE_ARGS, float_exp_trailing_us); // float-exp-trailing-us

	parsing_should_fail(FILE_LINE_ARGS, float_inf_incomplete_1); // float-inf-incomplete-1

	parsing_should_fail(FILE_LINE_ARGS, float_inf_incomplete_2); // float-inf-incomplete-2

	parsing_should_fail(FILE_LINE_ARGS, float_inf_incomplete_3); // float-inf-incomplete-3

	parsing_should_fail(FILE_LINE_ARGS, float_inf_underscore); // float-inf_underscore

	parsing_should_fail(FILE_LINE_ARGS, float_leading_point_neg); // float-leading-point-neg

	parsing_should_fail(FILE_LINE_ARGS, float_leading_point_plus); // float-leading-point-plus

	parsing_should_fail(FILE_LINE_ARGS, float_leading_point); // float-leading-point

	parsing_should_fail(FILE_LINE_ARGS, float_leading_us); // float-leading-us

	parsing_should_fail(FILE_LINE_ARGS, float_leading_zero_neg); // float-leading-zero-neg

	parsing_should_fail(FILE_LINE_ARGS, float_leading_zero_plus); // float-leading-zero-plus

	parsing_should_fail(FILE_LINE_ARGS, float_leading_zero); // float-leading-zero

	parsing_should_fail(FILE_LINE_ARGS, float_nan_incomplete_1); // float-nan-incomplete-1

	parsing_should_fail(FILE_LINE_ARGS, float_nan_incomplete_2); // float-nan-incomplete-2

	parsing_should_fail(FILE_LINE_ARGS, float_nan_incomplete_3); // float-nan-incomplete-3

	parsing_should_fail(FILE_LINE_ARGS, float_nan_underscore); // float-nan_underscore

	parsing_should_fail(FILE_LINE_ARGS, float_trailing_point_min); // float-trailing-point-min

	parsing_should_fail(FILE_LINE_ARGS, float_trailing_point_plus); // float-trailing-point-plus

	parsing_should_fail(FILE_LINE_ARGS, float_trailing_point); // float-trailing-point

	parsing_should_fail(FILE_LINE_ARGS, float_trailing_us); // float-trailing-us

	parsing_should_fail(FILE_LINE_ARGS, float_us_after_point); // float-us-after-point

	parsing_should_fail(FILE_LINE_ARGS, float_us_before_point); // float-us-before-point

	parsing_should_fail(FILE_LINE_ARGS, inline_table_double_comma); // inline-table-double-comma

	parsing_should_fail(FILE_LINE_ARGS, inline_table_empty); // inline-table-empty

	parsing_should_fail(FILE_LINE_ARGS, inline_table_no_comma); // inline-table-no-comma

#if !TOML_LANG_UNRELEASED

	parsing_should_fail(FILE_LINE_ARGS, inline_table_linebreak_1); // inline-table-linebreak-1

	parsing_should_fail(FILE_LINE_ARGS, inline_table_linebreak_2); // inline-table-linebreak-2

	parsing_should_fail(FILE_LINE_ARGS, inline_table_linebreak_3); // inline-table-linebreak-3

	parsing_should_fail(FILE_LINE_ARGS, inline_table_linebreak_4); // inline-table-linebreak-4

	parsing_should_fail(FILE_LINE_ARGS, inline_table_trailing_comma); // inline-table-trailing-comma

#endif // !TOML_LANG_UNRELEASED

	parsing_should_fail(FILE_LINE_ARGS, integer_capital_bin); // integer-capital-bin

	parsing_should_fail(FILE_LINE_ARGS, integer_capital_hex); // integer-capital-hex

	parsing_should_fail(FILE_LINE_ARGS, integer_capital_oct); // integer-capital-oct

	parsing_should_fail(FILE_LINE_ARGS, integer_double_sign_nex); // integer-double-sign-nex

	parsing_should_fail(FILE_LINE_ARGS, integer_double_sign_plus); // integer-double-sign-plus

	parsing_should_fail(FILE_LINE_ARGS, integer_double_us); // integer-double-us

	parsing_should_fail(FILE_LINE_ARGS, integer_invalid_bin); // integer-invalid-bin

	parsing_should_fail(FILE_LINE_ARGS, integer_invalid_hex); // integer-invalid-hex

	parsing_should_fail(FILE_LINE_ARGS, integer_invalid_oct); // integer-invalid-oct

	parsing_should_fail(FILE_LINE_ARGS, integer_leading_us_bin); // integer-leading-us-bin

	parsing_should_fail(FILE_LINE_ARGS, integer_leading_us_hex); // integer-leading-us-hex

	parsing_should_fail(FILE_LINE_ARGS, integer_leading_us_oct); // integer-leading-us-oct

	parsing_should_fail(FILE_LINE_ARGS, integer_leading_us); // integer-leading-us

	parsing_should_fail(FILE_LINE_ARGS, integer_leading_zero_1); // integer-leading-zero-1

	parsing_should_fail(FILE_LINE_ARGS, integer_leading_zero_2); // integer-leading-zero-2

	parsing_should_fail(FILE_LINE_ARGS, integer_leading_zero_sign_1); // integer-leading-zero-sign-1

	parsing_should_fail(FILE_LINE_ARGS, integer_leading_zero_sign_2); // integer-leading-zero-sign-2

	parsing_should_fail(FILE_LINE_ARGS, integer_negative_bin); // integer-negative-bin

	parsing_should_fail(FILE_LINE_ARGS, integer_negative_hex); // integer-negative-hex

	parsing_should_fail(FILE_LINE_ARGS, integer_negative_oct); // integer-negative-oct

	parsing_should_fail(FILE_LINE_ARGS, integer_positive_bin); // integer-positive-bin

	parsing_should_fail(FILE_LINE_ARGS, integer_positive_hex); // integer-positive-hex

	parsing_should_fail(FILE_LINE_ARGS, integer_positive_oct); // integer-positive-oct

	parsing_should_fail(FILE_LINE_ARGS, integer_text_after_integer); // integer-text-after-integer

	parsing_should_fail(FILE_LINE_ARGS, integer_trailing_us_bin); // integer-trailing-us-bin

	parsing_should_fail(FILE_LINE_ARGS, integer_trailing_us_hex); // integer-trailing-us-hex

	parsing_should_fail(FILE_LINE_ARGS, integer_trailing_us_oct); // integer-trailing-us-oct

	parsing_should_fail(FILE_LINE_ARGS, integer_trailing_us); // integer-trailing-us

	parsing_should_fail(FILE_LINE_ARGS, integer_us_after_bin); // integer-us-after-bin

	parsing_should_fail(FILE_LINE_ARGS, integer_us_after_hex); // integer-us-after-hex

	parsing_should_fail(FILE_LINE_ARGS, integer_us_after_oct); // integer-us-after-oct

	parsing_should_fail(FILE_LINE_ARGS, key_after_array); // key-after-array

	parsing_should_fail(FILE_LINE_ARGS, key_after_table); // key-after-table

	parsing_should_fail(FILE_LINE_ARGS, key_after_value); // key-after-value

	parsing_should_fail(FILE_LINE_ARGS, key_bare_invalid_character); // key-bare-invalid-character

	parsing_should_fail(FILE_LINE_ARGS, key_dotted_redefine_table); // key-dotted-redefine-table

	parsing_should_fail(FILE_LINE_ARGS, key_duplicate_keys); // key-duplicate-keys

	parsing_should_fail(FILE_LINE_ARGS, key_duplicate); // key-duplicate

	parsing_should_fail(FILE_LINE_ARGS, key_empty); // key-empty

	parsing_should_fail(FILE_LINE_ARGS, key_escape); // key-escape

	parsing_should_fail(FILE_LINE_ARGS, key_hash); // key-hash

	parsing_should_fail(FILE_LINE_ARGS, key_multiline); // key-multiline

	parsing_should_fail(FILE_LINE_ARGS, key_newline); // key-newline

	parsing_should_fail(FILE_LINE_ARGS, key_no_eol); // key-no-eol

	parsing_should_fail(FILE_LINE_ARGS, key_open_bracket); // key-open-bracket

	parsing_should_fail(FILE_LINE_ARGS, key_partial_quoted); // key-partial-quoted

	parsing_should_fail(FILE_LINE_ARGS, key_single_open_bracket); // key-single-open-bracket

	parsing_should_fail(FILE_LINE_ARGS, key_space); // key-space

	parsing_should_fail(FILE_LINE_ARGS, key_start_bracket); // key-start-bracket

	parsing_should_fail(FILE_LINE_ARGS, key_two_equals); // key-two-equals

	parsing_should_fail(FILE_LINE_ARGS, key_two_equals2); // key-two-equals2

	parsing_should_fail(FILE_LINE_ARGS, key_two_equals3); // key-two-equals3

	parsing_should_fail(FILE_LINE_ARGS, key_without_value_1); // key-without-value-1

	parsing_should_fail(FILE_LINE_ARGS, key_without_value_2); // key-without-value-2

#if !TOML_LANG_UNRELEASED && UNICODE_LITERALS_OK

	parsing_should_fail(FILE_LINE_ARGS, key_special_character); // key-special-character

#endif // !TOML_LANG_UNRELEASED && UNICODE_LITERALS_OK

	parsing_should_fail(FILE_LINE_ARGS, string_bad_byte_escape); // string-bad-byte-escape

	parsing_should_fail(FILE_LINE_ARGS, string_bad_codepoint); // string-bad-codepoint

	parsing_should_fail(FILE_LINE_ARGS, string_bad_concat); // string-bad-concat

	parsing_should_fail(FILE_LINE_ARGS, string_bad_escape); // string-bad-escape

	parsing_should_fail(FILE_LINE_ARGS, string_bad_multiline); // string-bad-multiline

	parsing_should_fail(FILE_LINE_ARGS, string_bad_slash_escape); // string-bad-slash-escape

	parsing_should_fail(FILE_LINE_ARGS, string_bad_uni_esc); // string-bad-uni-esc

	parsing_should_fail(FILE_LINE_ARGS, string_basic_multiline_out_of_range_unicode_escape_1); // string-basic-multiline-out-of-range-unicode-escape-1

	parsing_should_fail(FILE_LINE_ARGS, string_basic_multiline_out_of_range_unicode_escape_2); // string-basic-multiline-out-of-range-unicode-escape-2

	parsing_should_fail(FILE_LINE_ARGS, string_basic_multiline_quotes); // string-basic-multiline-quotes

	parsing_should_fail(FILE_LINE_ARGS, string_basic_multiline_unknown_escape); // string-basic-multiline-unknown-escape

	parsing_should_fail(FILE_LINE_ARGS, string_basic_out_of_range_unicode_escape_1); // string-basic-out-of-range-unicode-escape-1

	parsing_should_fail(FILE_LINE_ARGS, string_basic_out_of_range_unicode_escape_2); // string-basic-out-of-range-unicode-escape-2

	parsing_should_fail(FILE_LINE_ARGS, string_basic_unknown_escape); // string-basic-unknown-escape

	parsing_should_fail(FILE_LINE_ARGS, string_literal_multiline_quotes_1); // string-literal-multiline-quotes-1

	parsing_should_fail(FILE_LINE_ARGS, string_literal_multiline_quotes_2); // string-literal-multiline-quotes-2

	parsing_should_fail(FILE_LINE_ARGS, string_missing_quotes); // string-missing-quotes

	parsing_should_fail(FILE_LINE_ARGS, string_multiline_escape_space); // string-multiline-escape-space

	parsing_should_fail(FILE_LINE_ARGS, string_multiline_no_close_2); // string-multiline-no-close-2

	parsing_should_fail(FILE_LINE_ARGS, string_multiline_no_close); // string-multiline-no-close

	parsing_should_fail(FILE_LINE_ARGS, string_multiline_quotes_1); // string-multiline-quotes-1

	parsing_should_fail(FILE_LINE_ARGS, string_multiline_quotes_2); // string-multiline-quotes-2

	parsing_should_fail(FILE_LINE_ARGS, string_no_close); // string-no-close

	parsing_should_fail(FILE_LINE_ARGS, string_text_after_string); // string-text-after-string

	parsing_should_fail(FILE_LINE_ARGS, string_wrong_close); // string-wrong-close

#if !TOML_LANG_UNRELEASED

	parsing_should_fail(FILE_LINE_ARGS, string_basic_byte_escapes); // string-basic-byte-escapes

#endif // !TOML_LANG_UNRELEASED

	parsing_should_fail(FILE_LINE_ARGS, table_array_empty); // table-array-empty

	parsing_should_fail(FILE_LINE_ARGS, table_array_implicit); // table-array-implicit

	parsing_should_fail(FILE_LINE_ARGS, table_array_missing_bracket); // table-array-missing-bracket

	parsing_should_fail(FILE_LINE_ARGS, table_duplicate_key_table); // table-duplicate-key-table

	parsing_should_fail(FILE_LINE_ARGS, table_duplicate_table_array); // table-duplicate-table-array

	parsing_should_fail(FILE_LINE_ARGS, table_duplicate_table_array2); // table-duplicate-table-array2

	parsing_should_fail(FILE_LINE_ARGS, table_duplicate); // table-duplicate

	parsing_should_fail(FILE_LINE_ARGS, table_empty_implicit_table); // table-empty-implicit-table

	parsing_should_fail(FILE_LINE_ARGS, table_empty); // table-empty

	parsing_should_fail(FILE_LINE_ARGS, table_equals_sign); // table-equals-sign

	parsing_should_fail(FILE_LINE_ARGS, table_injection_1); // table-injection-1

	parsing_should_fail(FILE_LINE_ARGS, table_injection_2); // table-injection-2

	parsing_should_fail(FILE_LINE_ARGS, table_llbrace); // table-llbrace

	parsing_should_fail(FILE_LINE_ARGS, table_nested_brackets_close); // table-nested-brackets-close

	parsing_should_fail(FILE_LINE_ARGS, table_nested_brackets_open); // table-nested-brackets-open

	parsing_should_fail(FILE_LINE_ARGS, table_quoted_no_close); // table-quoted-no-close

	parsing_should_fail(FILE_LINE_ARGS, table_redefine); // table-redefine

	parsing_should_fail(FILE_LINE_ARGS, table_rrbrace); // table-rrbrace

	parsing_should_fail(FILE_LINE_ARGS, table_text_after_table); // table-text-after-table

	parsing_should_fail(FILE_LINE_ARGS, table_whitespace); // table-whitespace

	parsing_should_fail(FILE_LINE_ARGS, table_with_pound); // table-with-pound
}

